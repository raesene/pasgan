package dockerfile

import (
	"fmt"
	"io"
	"regexp"
	"sort"
	"strings"
	"time"
	
	"github.com/raesene/pasgan/internal/docker"
)

// Instruction represents a Dockerfile instruction
type Instruction struct {
	Command   string
	Arguments string
	Time      time.Time
	EmptyLayer bool
}

// Generator creates Dockerfile content from Docker image metadata
type Generator struct {
	metadata *docker.ImageMetadata
}

// NewGenerator creates a new Dockerfile generator
func NewGenerator(metadata *docker.ImageMetadata) *Generator {
	return &Generator{
		metadata: metadata,
	}
}

// Generate produces a Dockerfile based on image metadata
func (g *Generator) Generate(writer io.Writer) error {
	if g.metadata == nil {
		return fmt.Errorf("no metadata provided")
	}
	
	// Write header
	fmt.Fprintln(writer, "# Generated by Pasgan")
	fmt.Fprintln(writer, "# This is a best-effort reconstruction and may require manual adjustments")
	fmt.Fprintln(writer)
	
	// Process history entries into Dockerfile instructions
	instructions := g.processHistory()
	
	// Write instructions
	for _, instruction := range instructions {
		if instruction.Command == "COMMENT" {
			// Write comments
			fmt.Fprintf(writer, "# %s\n", instruction.Arguments)
		} else {
			// Handle multi-line RUN instructions
			if instruction.Command == "RUN" && strings.Contains(instruction.Arguments, "\n") {
				// Fix escaped backslashes in continuation lines
				args := strings.ReplaceAll(instruction.Arguments, "\n", " \\\n    ")
				// Remove double backslashes that might appear when a line already ends with a backslash
				args = strings.ReplaceAll(args, "\\ \\\n", " \\\n")
				fmt.Fprintf(writer, "%s %s\n", instruction.Command, args)
			} else {
				fmt.Fprintf(writer, "%s %s\n", instruction.Command, instruction.Arguments)
			}
		}
	}
	
	return nil
}

// processHistory converts history entries to Dockerfile instructions
func (g *Generator) processHistory() []Instruction {
	var instructions []Instruction
	var baseImageFound bool
	
	// Process history entries in chronological order
	for i, entry := range g.historyAscending() {
		// Skip empty history entries
		if entry.CreatedBy == "" {
			continue
		}
		
		// Skip BuildKit metadata comments
		if strings.Contains(entry.CreatedBy, "buildkit.dockerfile.v0") && strings.HasPrefix(entry.CreatedBy, "/bin/sh -c #(nop)") {
			continue
		}
		
		// Determine timestamp for sorting
		timestamp, _ := time.Parse(time.RFC3339Nano, entry.Created)
		
		// Process the command
		command, args := g.parseHistoryCommand(entry.CreatedBy)
		
		// Skip if the command contains buildkit metadata
		if strings.Contains(args, "buildkit") {
			continue
		}
		
		// Handle special cases
		switch command {
		case "FROM":
			// Only use the first FROM instruction
			if !baseImageFound {
				instructions = append(instructions, Instruction{
					Command:    command,
					Arguments:  args,
					Time:       timestamp,
					EmptyLayer: entry.EmptyLayer,
				})
				baseImageFound = true
			}
		case "LABEL", "ENV", "EXPOSE", "WORKDIR", "USER", "VOLUME", "ENTRYPOINT", "CMD", "HEALTHCHECK", "SHELL", "STOPSIGNAL":
			// These are all standard Dockerfile instructions
			instructions = append(instructions, Instruction{
				Command:    command,
				Arguments:  args,
				Time:       timestamp,
				EmptyLayer: entry.EmptyLayer,
			})
		case "RUN":
			// For RUN instructions, try to expand package manager commands to make them more readable
			if i > 0 && !strings.Contains(args, "buildkit") {
				expandedArgs := g.expandRun(args)
				instructions = append(instructions, Instruction{
					Command:    command,
					Arguments:  expandedArgs,
					Time:       timestamp,
					EmptyLayer: entry.EmptyLayer,
				})
			}
		default:
			// For unknown or complex commands, add as a comment if it's not a basic /bin/sh -c
			if !strings.HasPrefix(entry.CreatedBy, "/bin/sh -c #(nop)") && 
			   command != "" && !entry.EmptyLayer && !strings.Contains(entry.CreatedBy, "buildkit") {
				instructions = append(instructions, Instruction{
					Command:    "RUN",
					Arguments:  entry.CreatedBy,
					Time:       timestamp,
					EmptyLayer: entry.EmptyLayer,
				})
			}
		}
		
		// Add any comment if present, except buildkit comments
		if entry.Comment != "" && !strings.Contains(entry.Comment, "buildkit") {
			instructions = append(instructions, Instruction{
				Command:    "COMMENT",
				Arguments:  entry.Comment,
				Time:       timestamp,
				EmptyLayer: true,
			})
		}
	}
	
	// If we need to add a FROM instruction (none was found in history)
	if !baseImageFound && len(g.metadata.RepoTags) > 0 {
		// Use the first repo tag
		baseImage := "scratch" // Default to scratch
		if len(g.metadata.RepoTags) > 0 && g.metadata.RepoTags[0] != "" {
			baseImage = g.metadata.RepoTags[0]
		}
		
		// Insert at the beginning
		instructions = append([]Instruction{
			{
				Command:    "FROM",
				Arguments:  baseImage,
				Time:       time.Time{},
				EmptyLayer: true,
			},
		}, instructions...)
	}
	
	// Filter out any instructions with buildkit in the arguments
	filteredInstructions := make([]Instruction, 0, len(instructions))
	for _, inst := range instructions {
		if !strings.Contains(strings.ToLower(inst.Arguments), "buildkit") {
			filteredInstructions = append(filteredInstructions, inst)
		}
	}
	
	return filteredInstructions
}

// historyAscending returns the history entries sorted by creation time (oldest first)
func (g *Generator) historyAscending() []docker.History {
	history := make([]docker.History, len(g.metadata.History))
	copy(history, g.metadata.History)
	
	// Sort by creation time
	sort.Slice(history, func(i, j int) bool {
		timeI, _ := time.Parse(time.RFC3339Nano, history[i].Created)
		timeJ, _ := time.Parse(time.RFC3339Nano, history[j].Created)
		return timeI.Before(timeJ)
	})
	
	return history
}

// parseHistoryCommand extracts the Dockerfile instruction and arguments from a history command
func (g *Generator) parseHistoryCommand(cmd string) (string, string) {
	// Trim any trailing whitespace
	cmd = strings.TrimSpace(cmd)
	
	// Common prefixes in Docker history
	if strings.HasPrefix(cmd, "/bin/sh -c #(nop) ") {
		// This is a non-executing instruction (COPY, ENV, etc.)
		remainder := strings.TrimPrefix(cmd, "/bin/sh -c #(nop) ")
		remainder = strings.TrimSpace(remainder)
		
		// Extract the instruction
		parts := strings.SplitN(remainder, " ", 2)
		if len(parts) == 2 {
			// Clean up quotes if needed
			args := parts[1]
			if strings.HasPrefix(args, "\"") && strings.HasSuffix(args, "\"") {
				args = args[1 : len(args)-1]
			}
			return parts[0], args
		}
		return parts[0], ""
	} else if strings.HasPrefix(cmd, "/bin/sh -c #(nop)") {
		// Handle case where there's no space after #(nop)
		remainder := strings.TrimPrefix(cmd, "/bin/sh -c #(nop)")
		remainder = strings.TrimSpace(remainder)
		
		// Extract the instruction
		parts := strings.SplitN(remainder, " ", 2)
		if len(parts) == 2 {
			return parts[0], parts[1]
		}
		return parts[0], ""
	} else if strings.HasPrefix(cmd, "/bin/sh -c ") {
		// This is a RUN instruction
		remainder := strings.TrimPrefix(cmd, "/bin/sh -c ")
		
		// Remove quotes if the entire command is quoted
		if strings.HasPrefix(remainder, "\"") && strings.HasSuffix(remainder, "\"") {
			remainder = remainder[1 : len(remainder)-1]
		}
		
		return "RUN", remainder
	} else if strings.HasPrefix(cmd, "bash -c ") {
		// This is a RUN instruction with bash
		remainder := strings.TrimPrefix(cmd, "bash -c ")
		
		// Remove quotes if the entire command is quoted
		if strings.HasPrefix(remainder, "\"") && strings.HasSuffix(remainder, "\"") {
			remainder = remainder[1 : len(remainder)-1]
		}
		
		return "RUN", remainder
	}
	
	// For other formats, try to guess the instruction
	// Look for common Dockerfile instructions
	instructions := []string{
		"FROM", "RUN", "CMD", "LABEL", "MAINTAINER", "EXPOSE", "ENV", 
		"ADD", "COPY", "ENTRYPOINT", "VOLUME", "USER", "WORKDIR", 
		"ARG", "ONBUILD", "STOPSIGNAL", "HEALTHCHECK", "SHELL",
	}
	
	for _, inst := range instructions {
		if strings.HasPrefix(cmd, inst+" ") {
			parts := strings.SplitN(cmd, " ", 2)
			return parts[0], strings.TrimSpace(parts[1])
		}
	}
	
	// Special case for buildkit encoded commands
	if strings.Contains(cmd, "buildkit.dockerfile.v0") {
		// Try to extract the instruction
		for _, inst := range instructions {
			if strings.Contains(cmd, inst+" ") {
				// Extract everything after the instruction
				parts := strings.SplitN(cmd, inst+" ", 2)
				if len(parts) == 2 {
					return inst, strings.TrimSpace(parts[1])
				}
			}
		}
	}
	
	// If we can't determine the instruction, treat it as a RUN command
	return "RUN", cmd
}

// expandRun expands complex RUN commands to make them more readable
func (g *Generator) expandRun(cmd string) string {
	// First, clean up any existing escaped newlines to avoid conflicts
	cmd = strings.ReplaceAll(cmd, "\\\n", " ")
	
	// Clean up excess whitespace
	cmd = strings.TrimSpace(cmd)
	
	// Expand apt-get commands
	aptRegex := regexp.MustCompile(`apt-get\s+\w+\s+(-\w+\s+)*([^&|;]+)`)
	matches := aptRegex.FindAllStringSubmatchIndex(cmd, -1)
	
	if len(matches) > 0 {
		// If we found apt-get commands, try to format them nicely
		lines := strings.Split(cmd, "&&")
		for i, line := range lines {
			lines[i] = strings.TrimSpace(line)
		}
		return strings.Join(lines, " \\\n    && ")
	}
	
	// Handle long lines
	if len(cmd) > 80 {
		// Split on logical operators
		for _, sep := range []string{" && ", " || ", " ; "} {
			if strings.Contains(cmd, sep) {
				parts := strings.Split(cmd, sep)
				for i, part := range parts {
					parts[i] = strings.TrimSpace(part)
				}
				joiner := sep
				if sep == " ; " {
					joiner = " ;"
				}
				return strings.Join(parts, joiner+" \\\n    ")
			}
		}
	}
	
	return cmd
}

// cleanHistoryCommand extracts the actual command from a history entry
func cleanHistoryCommand(cmd string) string {
	// Common prefixes in Docker history
	prefixes := []string{
		"/bin/sh -c #(nop) ",
		"/bin/sh -c",
		"bash -c",
	}
	
	result := cmd
	for _, prefix := range prefixes {
		if strings.HasPrefix(cmd, prefix) {
			result = strings.TrimPrefix(cmd, prefix)
			break
		}
	}
	
	return strings.TrimSpace(result)
}